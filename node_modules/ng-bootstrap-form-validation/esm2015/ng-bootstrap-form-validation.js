import { CommonModule } from '@angular/common';
import { Component, ContentChildren, Directive, ElementRef, EventEmitter, HostBinding, HostListener, Inject, Injectable, InjectionToken, Input, NgModule, Output } from '@angular/core';
import { FormControlName, FormGroup } from '@angular/forms';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FormValidationDirective {
    constructor() {
        this.validSubmit = new EventEmitter();
    }
    /**
     * @return {?}
     */
    onSubmit() {
        this.markAsTouchedAndDirty(this.formGroup);
        if (this.formGroup.valid) {
            this.validSubmit.emit(this.formGroup.value);
        }
    }
    /**
     * @param {?} formGroup
     * @return {?}
     */
    markAsTouchedAndDirty(formGroup) {
        Object.keys(formGroup.controls).forEach(key => {
            if (formGroup.controls[key] instanceof FormGroup) {
                this.markAsTouchedAndDirty(/** @type {?} */ (formGroup.controls[key]));
            }
            else {
                formGroup.controls[key].markAsDirty();
                formGroup.controls[key].markAsTouched();
                formGroup.controls[key].updateValueAndValidity();
            }
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
}
FormValidationDirective.decorators = [
    { type: Directive, args: [{
                selector: "form[formGroup]"
            },] },
];
/** @nocollapse */
FormValidationDirective.ctorParameters = () => [];
FormValidationDirective.propDecorators = {
    "formGroup": [{ type: Input },],
    "validSubmit": [{ type: Output },],
    "onSubmit": [{ type: HostListener, args: ["submit",] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const DEFAULT_ERRORS = [
    {
        error: "required",
        format: label => `${label} is required`
    },
    {
        error: "pattern",
        format: label => `${label} is invalid`
    },
    {
        error: "minlength",
        format: (label, error) => `${label} must be at least ${error.requiredLength} characters`
    },
    {
        error: "maxlength",
        format: (label, error) => `${label} must be no longer than ${error.requiredLength} characters`
    },
    {
        error: "requiredTrue",
        format: (label, error) => `${label} is required`
    },
    {
        error: "email",
        format: (label, error) => `Invalid email address`
    },
    {
        error: "max",
        format: (label, error) => `${label} must be no greater than ${error.max}`
    },
    {
        error: "min",
        format: (label, error) => `${label} must be no less than ${error.min}`
    }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const CUSTOM_ERROR_MESSAGES = new InjectionToken("ng-bootstrap-form-validation custom error messages");

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class ErrorMessageService {
    /**
     * @param {?=} customErrorMessages
     */
    constructor(customErrorMessages = []) {
        this.customErrorMessages = customErrorMessages;
        this.defaultErrors = DEFAULT_ERRORS;
    }
    /**
     * @return {?}
     */
    get errorMessages() {
        return [...this.customErrorMessages, ...this.defaultErrors];
    }
}
ErrorMessageService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
ErrorMessageService.ctorParameters = () => [
    { type: Array, decorators: [{ type: Inject, args: [CUSTOM_ERROR_MESSAGES,] },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FormGroupComponent {
    /**
     * @param {?} elRef
     * @param {?} errorMessageService
     */
    constructor(elRef, errorMessageService) {
        this.elRef = elRef;
        this.errorMessageService = errorMessageService;
        this.customErrorMessages = [];
        this.validationDisabled = false;
    }
    /**
     * @return {?}
     */
    get hasErrors() {
        return (this.FormControlNames.some(c => !c.valid && c.dirty && c.touched) &&
            !this.validationDisabled);
    }
    /**
     * @return {?}
     */
    get hasSuccess() {
        return (!this.FormControlNames.some(c => !c.valid) &&
            this.FormControlNames.some(c => c.dirty && c.touched) &&
            !this.validationDisabled);
    }
    /**
     * @return {?}
     */
    get label() {
        const /** @type {?} */ label = this.elRef.nativeElement.querySelector("label");
        return label && label.textContent ? label.textContent.trim() : "This field";
    }
    /**
     * @return {?}
     */
    get isDirtyAndTouched() {
        return this.FormControlNames.some(c => c.dirty && c.touched);
    }
    /**
     * @return {?}
     */
    get errorMessages() {
        return [
            ...this.customErrorMessages,
            ...this.errorMessageService.errorMessages
        ];
    }
    /**
     * @return {?}
     */
    get messages() {
        const /** @type {?} */ messages = [];
        if (!this.isDirtyAndTouched || this.validationDisabled)
            return messages;
        this.FormControlNames.filter(c => !c.valid).forEach(control => {
            Object.keys(control.errors).forEach(key => {
                const /** @type {?} */ error = this.errorMessages.find(error => error.error === key);
                if (!error)
                    return;
                messages.push(error.format(this.label, control.errors[key]));
            });
        });
        return messages;
    }
}
FormGroupComponent.decorators = [
    { type: Component, args: [{
                selector: ".form-group",
                template: `
    <ng-content></ng-content>
    <span class="help-block" *ngFor="let message of messages">{{message}}</span>
  `
            },] },
];
/** @nocollapse */
FormGroupComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: ErrorMessageService, },
];
FormGroupComponent.propDecorators = {
    "FormControlNames": [{ type: ContentChildren, args: [FormControlName,] },],
    "customErrorMessages": [{ type: Input },],
    "validationDisabled": [{ type: Input },],
    "hasErrors": [{ type: HostBinding, args: ["class.has-error",] },],
    "hasSuccess": [{ type: HostBinding, args: ["class.has-success",] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NgBootstrapFormValidationModule {
    /**
     * @param {?=} customErrorMessages
     * @return {?}
     */
    static forRoot(customErrorMessages) {
        return {
            ngModule: NgBootstrapFormValidationModule,
            providers: [
                {
                    provide: ErrorMessageService,
                    useFactory: errorMessageServiceFactory,
                    deps: [CUSTOM_ERROR_MESSAGES]
                },
                {
                    provide: CUSTOM_ERROR_MESSAGES,
                    useValue: customErrorMessages
                }
            ]
        };
    }
}
NgBootstrapFormValidationModule.decorators = [
    { type: NgModule, args: [{
                declarations: [FormValidationDirective, FormGroupComponent],
                imports: [CommonModule],
                providers: [ErrorMessageService],
                exports: [FormValidationDirective, FormGroupComponent]
            },] },
];
/** @nocollapse */
NgBootstrapFormValidationModule.ctorParameters = () => [];
/**
 * @param {?=} customErrorMessages
 * @return {?}
 */
function errorMessageServiceFactory(customErrorMessages) {
    return new ErrorMessageService(customErrorMessages);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { errorMessageServiceFactory, NgBootstrapFormValidationModule, FormValidationDirective, FormGroupComponent, ErrorMessageService as ɵa, CUSTOM_ERROR_MESSAGES as ɵb };
//# sourceMappingURL=ng-bootstrap-form-validation.js.map
